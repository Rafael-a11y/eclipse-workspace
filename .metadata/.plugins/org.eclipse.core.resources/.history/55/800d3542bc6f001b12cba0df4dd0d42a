package br.com.abc.javacore.ZZKstreams.test;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.OptionalDouble;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class StreamTest5GerandoStreams {

	public static void main(String[] args) {
//		A diferença de range() para rangeClosed() é que o primeiro possui um número de limite exclusivo, no segundo, o número
//		de índice final é inclusivo.
		 IntStream.rangeClosed(1, 10).filter(n -> n % 2 == 0).forEach(p -> System.out.print( p + " "));
		 System.out.println();
		 IntStream.range(1, 10).filter(n -> n % 2 == 0).forEach(p -> System.out.print( p + " "));
		 
//		 Para criarmos uma stream<String>, podemos chamar o método estático of(), que retorna uma stream ordenada sequencial
//		 cujos elementos são os valores especificados, no caso do exemplo mostrado, usamos apenas 3 Strings. Usamos um map()
//		 para deixar a caixa de toda a stream gerada em caixa alta e depois usamos o forEach() para imprimir o valores com o
//		 método print().
		 Stream<String> stringStream = Stream.of("William", "DevDojo", "Acessem o facebook pelo amor de deus e curtam valeu");
		 System.out.println();
		 stringStream.map(String::toUpperCase).forEach(s -> System.out.print(s + " "));
		 
//		 Para o caso de você querer criar uma Stream vazia, use Object como tipo, depois chame o método estático empty(). Lembrando
//		 que usar o tipo Object não é obrigatório, é só para exemplificar.
//		 Criamos uma stream de inteiros a ´partir de um array de inteiros primitivos, a partir do método estático da classe
//		 Arrays que retorna um IntStream do pacote stream, que é um tipo de Stream que trabalha com tipos primitivos. Mas
//		 o que queremos aqui no caso não é chamar o map(), ou um filter(), o objetivo aqui é conseguir a média, por isso
//		 chamamos o average(), que por sua vez retorna um OptionalDouble, que é um Optional especializado em tipo primitivo
//		 Double. E por fim, como sabemos, em um Optional, o valor pode ou não estar presente, por este motivo, chamamos o método
//		 de instância getAsDouble(), que retorna o número caso este exista, caso contrário, lança um NoSuchElementException.
		 Stream<String> empty = Stream.empty();
		 int[] nums = {1, 2, 3, 4, 5};
		 OptionalDouble average = Arrays.stream(nums).average();
		 System.out.println("\n" + average.getAsDouble());
		 
//		 Usamos o try with resources para que o arquivo seja fechado automaticamente, pois bem, usamos uma variável de referência
//		 do tipo Stream<String> que aponta para o método estático da classe Files, o lines() que lê as linhas de um arquivo,
//		 como este método espera um Path de parâmetro, usamos o método estático get() que captura um arquivo, o método lines()
//		 também espera o método estático da classe abstrata Charset. Usamos em seguida um flatmap() para alcançar os valores
//		 mais internos que são as Strings no arquivo de tetxto, usamos o split("\n") com uma String "\n" dentro para o split()
//		 quebrar o texto do arquivo em várias Strings, ou seja, a cada quebra de linha, o texto é dividido em 2 Strings, depois
//		 usamos um filter() para filtrar as Strings, usando o contains() para saber se possuem a substring "File" seguido de
//		 um forEach() para imprimi-las.
		 try(Stream<String> lines = Files.lines(Paths.get("arquivo_renomeado.txt"), Charset.defaultCharset())){
			 lines.flatMap(line -> Arrays.stream(line.split("\n")))
			 .filter(p -> p.contains("File"))
			 .forEach(System.out::println);
		 }
		 catch(IOException e) {
			 e.printStackTrace();
		 }
//		 Gerando stream de valores infinitos, chamamos o iterate(), método estático da classe stream, onde fornecemos um valor
//		 seed e uma função UnaryOperator, onde n inicialmente é 1 e é somado com 2, que dá, logo n passa a valer 3 que é somado
//		 com 2, que dá cinco, e assim por diante, limatos a operação a 10 somas somente com o método limit().
		 Stream.iterate(1, n -> n + 2).limit(10).forEach(System.out::println);
//		 0,1,1,2,3,5,8,13,21,34,55...
//		 (0,1) (1,1) (1,2) (2,3) (3,5) (5,8) (8,13) (13,21) (21,34) (34,55)...
//		 O valor da direita é a soma dos dois valores anteriores, e o da esquerda é a repetição do valor mais a direita do
//		 parêntesis anterior. O método iterate esperea um valor semente e uma UnaryOperator, cuja expressão retorna o mesmo
//		 dado de entrada, modificado, claro. Sendo assim, crio um array de inteiuros com duas posições, 0 e 1, cujos valores
//		 são 0,1. N a função lambda eu digo que o valor do array na primeira posição é equivalente a segunda posição, e que a
//		 segunda posição é o resultado da primeira posição somado com o vcalor da segunda posição, essa operação é iterada várias
//		 vezes, seguido de uma impressão com um forEach
		 Stream.iterate(new int[] {0,1} , a -> new int[] {a[1], a[0] + a[1]})
		 .limit(5)
		 .forEach(t -> System.out.println(Arrays.toString(t)));
		 
		 Stream.iterate(new int[] {0,1} , a -> new int[] {a[1], a[0] + a[1]})
		 .limit(10)
		 .map(t -> t[0])
		 .forEach((e) -> System.out.println(e));
		 System.out.println();
//		 O generate() espera de parâmetro um lambda Supplier, usamos um reference method a um método estático concreto de uma
//		 classe concreta, isso é possível pois o functional Descriptor é totalmente compatível a uma função Supplier, algo
//		 que não recebe nada de parâmetro e retorna algum valor, usamos o limit() para limitar a 10 iterações e valores gerados,
//		  seguido de um forEach()
//		 Stream.generate(Math::random).limit(10).forEach(System.out::println);
		 
//		 O método estático current() cria e retorna o objeto ThreaadLocalRandom, usamos uma lambda Supplier de parâmetro para
//		 o generate() onde o objeto ThreadLocalRandom chama o método nextInt(), responsável por criar valores inteiros dentro
//		 de um intervalo de valores, intervalo esse fornecido de parâmetro do método, sendo o primeiro número de índice inclusivo
//		 e o último deíndice exclusivo, seguido de um limit(100) para limitar a 100 valores gerados de 1 a 99, e em seguida
//		 um forEach para imprimir.
 		 ThreadLocalRandom t = ThreadLocalRandom.current();
		 Stream.generate(() -> t.nextInt(1,100)).limit(100).forEach(System.out::println);
	}	

}
